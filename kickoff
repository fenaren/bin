#!/bin/bash

# Prints appropriate usage
display_usage() {
    echo "Usage: $0 [-c | --clear] [-e | --email] [-h | --help] CMD"
}

BASENAME=$(basename $0)

# Reports go here (intentionally unquoted)
REPORT_DIR=~/.${BASENAME}

CLEAR_SET=false

CMD=
CMD_SET=false

EMAIL=
EMAIL_SET=false

VERBOSITY=0

while [ -n "$1" ]
do
    case "$1" in

        -c | --clear)
            CLEAR_SET=true
            ;;

        -e | --email)
            EMAIL="$2"
            EMAIL_SET=true
            shift
            ;;

        -h | --help)
            display_usage
            exit 0
            ;;

        -v | --verbose)
            VERBOSITY=$((VERBOSITY + 1))
            ;;

        *)
            CMD="$*"
            CMD_SET=true
            break
            ;;
    esac

    # We're done with the current argument, move to the next.
    shift
done

if [ "${CLEAR_SET}" == true ]; then

    rm -rf "${REPORT_DIR}"/*

    if [ "${CMD_SET}" == false ]; then
        exit 0
    fi
fi

if [ "${CMD_SET}" == false ]; then
    display_usage
    exit 1
fi

FROM=$(whoami)@$(hostname)

# Come up with a short name to describe this job.  The "$$" at the end is
# supposed to be there.
CMD_NAME=$(echo "${CMD}" | cut -d " " -f 1)$$

# Make the report directory if it doesn't already exist
if ! test -d "${REPORT_DIR}"; then

    if [ "${VERBOSITY}" -gt 0 ]; then
        echo "Creating report directory ${REPORT_DIR}"
    fi

    mkdir "${REPORT_DIR}"
fi

# Construct the subject line
MAIL_SUBJECT="${CMD_NAME} done on ${FROM}"

# Construct the header lines
HEADER=
HEADER+="From: ${FROM}\n"
HEADER+="To: ${EMAIL}\n"
HEADER+="Subject: ${MAIL_SUBJECT}\n"

# If the user has SMTP_RELAY set then pass that to sendemail
SMTP_RELAY_CMD=
if [ -n "${SMTP_RELAY}" ]; then
    SMTP_RELAY_CMD="--smtp-relay ${SMTP_RELAY}"
fi

# Files containing output from the command will use this prefix
OUTPUT_DIR="${REPORT_DIR}/${CMD_NAME}"
if [ "${VERBOSITY}" -gt 0 ]; then
    echo "Reports will be written to ${OUTPUT_DIR}"
fi

mkdir -p "${OUTPUT_DIR}"

# This redirects output from the command to where we want it
WRAPPED_CMD="${CMD} > ${OUTPUT_DIR}/out 2> ${OUTPUT_DIR}/err"

# This adds timing and redirects the time output where we want it.  A subshell
# has to be used here instead of bracket grouping for some reason.
WRAPPED_CMD="time (${WRAPPED_CMD}) 2> ${OUTPUT_DIR}/time"

# This makes the whole thing uninterruptible.  Do this last.
WRAPPED_CMD="nohup bash -c '${WRAPPED_CMD}' > /dev/null 2> /dev/null "
WRAPPED_CMD+="< /dev/null &"

# Run the job and drop a .kickoff file in the user's home dir
# Send them an email if requested
# Do this all in the background
if [ "${EMAIL_SET}" == true ]; then

    (TIME=$(time (nohup "${CMD}" > /dev/null 2> /dev/null < /dev/null) 2>&1); \
        MAIL_BODY="${CMD}\n${TIME}"; \
        echo -e "${MAIL_BODY}" > ~/.kickoff_"${CMD_NAME}"; \
        echo -e "${HEADER}${MAIL_BODY}" | \
        sendemail --from "${FROM}" --to "${EMAIL} ${SMTP_RELAY_CMD}") &

else

    eval "${WRAPPED_CMD}"
    #time (eval "${WRAPPED_CMD}") 2> "${OUTPUT_DIR}/time"

    #TIME=$(time ${WRAPPED_CMD})

#            (TIME=$(time ("${WRAPPED_CMD}"); \
#        MAIL_BODY="${CMD}\n${TIME}"; \
#        echo -e "${MAIL_BODY}" > "${OUTPUT_DIR}") &

fi
